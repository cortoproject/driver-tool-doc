/* This is a managed file. Do not delete this comment. */

#include <driver/tool/doc/doc.h>
#include <parson/parson.h>

static char *CORTO_DOC_OUTPUT = "html/res";

static
int16_t doc_copyResources(void)
{
    char *src = corto_asprintf("%s/res", DRIVER_TOOL_DOC_ETC);
    char *output = CORTO_DOC_OUTPUT;
    if (corto_getenv("CORTO_DOCROOT")) {
        output = corto_asprintf("%s/res", corto_getenv("CORTO_DOCROOT"));
    }

    if (corto_mkdir(output)) {
        goto error;
    }

    corto_ll files = corto_opendir(src);
    if (!files) {
        goto error;
    }

    corto_iter it = corto_ll_iter(files);

    while (corto_iter_hasNext(&it)) {
        corto_string f = corto_iter_next(&it);
        corto_id file;
        sprintf(file, "%s/%s", src, f);
        if (corto_cp(file, output)) {
            goto error;
        }
    }

    corto_closedir(files);
    corto_dealloc(src);

    if (output != CORTO_DOC_OUTPUT) {
        free(output);
    }

    return 0;
error:
    return -1;
}

static
bool doc_in_dir(corto_ll dir, char *doc) {
    corto_iter it = corto_ll_iter(dir);
    while (corto_iter_hasNext(&it)) {
        char *f = corto_iter_next(&it);
        if (!strcmp(f, doc)) {
            return true;
        }
    }
    return false;
}

int cortomain(int argc, char *argv[]) {
    JSON_Value *json = NULL;
    int8_t ret = 0;
    bool doc_exists = corto_file_test("doc");
    uint32_t generated_count = 0;

    /* Keep track of files already in the doc folder, so only md files that are
       generated by the doxygen generator will be cleaned up */
    corto_ll in_doc = corto_opendir("doc");
    if (!in_doc) {
        /* doc folder doesn't exist- no problem */
        corto_catch();
    }

    json = json_parse_file("project.json");
    if (json) {
        JSON_Object *json_o = json_value_get_object(json);
        if (!json_o) {
            corto_throw("invalid JSON in project.json: expected object");
            goto error;
        }

        corto_info("Generating Doxygen XML from project");

        JSON_Array *json_a_doxy = json_object_dotget_array(json_o, "value.doxygen");
        if (json_a_doxy) {
            /* If headers are specified, use doxygen generator to generate markdown */
            if (corto_proc_cmd("corto pp -g doc/doxygen", &ret) || ret) {
                corto_throw("failed to invoke doxygen");
                goto error;
            }

            /* Cleanup generated doxygen files */
            corto_rm(".doxygen");
        }
        json_value_free(json);
        json = NULL;

        corto_info("Successfully generated Doxygen XML");
    }

    if (argc > 1) {
        int i;
        for (i = 1; i < argc; i ++) {
            char *md = argv[i];
            char *ext = strrchr(md, '.');
            if (ext && !strcmp(ext, ".md") && corto_file_test(md)) {
                char *name = corto_strdup(md);
                ext = strrchr(name, '.');
                *ext = '\0';

                if (corto_proc_cmd(
                        strarg("corto pp --name %s %s -g doc/html", name, md),
                    &ret) || ret)
                {
                    corto_throw("failed to invoke HTML generator for '%s'", md);
                    goto error;
                }
                generated_count ++;
                free (name);
            } else if (!corto_file_test(md)) {
                corto_throw("file '%s' not found!", md);
                goto error;
            }
        }

    } else if (corto_file_test("doc")) {
        corto_iter it;

        /* Generate HTML for all the .md files in the doc directory */
        if (corto_dir_iter("doc", "*.md", &it)) {
            goto error;
        }

        while (corto_iter_hasNext(&it)) {
            char *md = corto_iter_next(&it);
            char *name = corto_strdup(md), *ext = strchr(name, '.');
            if (ext) {
                ext[0] = '\0';
            }
            if (corto_proc_cmd(
                    strarg("corto pp --name %s doc/%s -g doc/html", name, md),
                &ret) || ret)
            {
                corto_throw("failed to invoke HTML generator for '%s'", md);
                goto error;
            }
            free(name);
            generated_count ++;
        }

    } else {
        corto_warning("no documentation available for project");
        corto_log("  To add documentation, add doxygen-style comments to your\n");
        corto_log("  headers, and then add a 'doc.headers' member to your\n");
        corto_log("  'project.json' file in which you specify the header files\n");
        corto_log("  for which you want to generate the documenation, like:\n");
        corto_log("  \"value\": {\n");
        corto_log("      \"doc\": {\n");
        corto_log("          \"headers\": [\"foo.h\", \"bar.h\"]\n");
        corto_log("      }\n");
        corto_log("  }\n");
    }

    /* Copy resources if files were generated */
    if (generated_count) {
        if (doc_copyResources()) {
            goto error;
        }
    }

    /* Delete (only) files generated by doxygen */
    if (!doc_exists && (!in_doc || !corto_ll_count(in_doc))) {
        if (corto_rm("doc")) {
            corto_throw(NULL);
        }
    } else {
        corto_ll new_in_doc = corto_opendir("doc");
        int in_doc_count = in_doc ? corto_ll_count(in_doc) : 0;
        if (in_doc_count != corto_ll_count(new_in_doc)) {
            corto_iter it = corto_ll_iter(new_in_doc);
            while (corto_iter_hasNext(&it)) {
                char *md = corto_iter_next(&it);
                if (!in_doc || !doc_in_dir(in_doc, md)) {
                    if (corto_rm(strarg("doc/%s", md))) {
                        corto_warning("failed to cleanup 'doc/%s'", md);
                    }
                }
            }
        }
        corto_closedir(new_in_doc);
    }

    if (in_doc) corto_closedir(in_doc);

    if (generated_count) {
        corto_info("HTML successfully generated for %d document(s)", generated_count);
    } else {
        corto_warning("no HTML generated- no markdown documents found in doc folder!");
    }

    return 0;
error:
    return -1;
}
